<!DOCTYPE html>
<!--
  Copyright 2019 the original author or authors.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  TODO:
    []
-->
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <!--meta property="twitter:image" content="https://javafxpert.github.io/grok-bloch/images/bloch-sphere.png"-->
    <title>v0.01 QSphere playground</title>
    <!--- Link to the last version of BabylonJS --->
    <!-- script src="https://cdn.babylonjs.com/babylon.js"></script -->
    <script src="js/thirdparty/babylon.js"></script>
    <script src="js/thirdparty/babylon.gui.min.js"></script>
    <script src="js/thirdparty/math.min.js"></script>
    <script src="js/qsphere.js"></script>
    <script src="js/hamming.js"></script>
    <script src="js/qutil.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width   : 100%;
            height  : 100%;
            margin  : 0;
            padding : 0;
        }

        #renderCanvas {
            width   : 100%;
            height  : 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<script>
    window.addEventListener('DOMContentLoaded', function(){

        let qSphere = null;

        // get the canvas DOM element
        const canvas = document.getElementById('renderCanvas');

        // load the 3D engine
        const engine = new BABYLON.Engine(canvas, true);

        // createScene function that creates and return the scene
        const createScene = function(){
            // Create the scene space
            const scene = new BABYLON.Scene(engine);

            // let stateVector = math.matrix([
            //     math.complex(1, 0),
            //     math.complex(0, 0),
            //     math.complex(0, 0),
            //     math.complex(0, 0)
            // ]);
            let stateVector = math.matrix([
                math.complex(1 / math.sqrt(8), 0),
                math.complex(-1 / math.sqrt(8), 0),
                math.complex(1 / math.sqrt(8), 0),
                math.complex(-1 / math.sqrt(8), 0),
                math.complex(1 / math.sqrt(8), 0),
                math.complex(-1 / math.sqrt(8), 0),
                math.complex(1 / math.sqrt(8), 0),
                math.complex(-1 / math.sqrt(8), 0)
            ]);
            let qSphere = new QSphere("qSphere", scene, stateVector);

            BABYLON.SceneOptimizer.OptimizeAsync(scene);

            scene.clearColor = new BABYLON.Color3( .75, .75, .75);

            // Add a camera to the scene and attach it to the canvas
            const camera = new BABYLON.ArcRotateCamera("camera1",  -Math.PI / 2.5, Math.PI / 2.5, 6, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            // Add lights to the scene
            const light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(-3, 7, 1), scene);

            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");



            scene.onPointerObservable.add((pointerInfo) => {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        // TODO: Find out how to identify that sphere was picked
                        if(pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh == qSphere.sphere) {
                            console.log("pickedPoint: " + pointerInfo.pickInfo.pickedPoint);

                        }
                        break;
                }
            });

            // return the created scene
            return scene;
        }


        // call the createScene function
        const scene = createScene();

        // run the render loop
        engine.runRenderLoop(function(){
            scene.render();
        });

        // the canvas/window resize event handler
        window.addEventListener('resize', function(){
            engine.resize();
        });
    });
</script>
</body>
</html>