<!DOCTYPE html>
<!--
  Copyright 2019 the original author or authors.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  TODO:
    [] Verify whether phase calculations are always correct when state is |1>
    [] Provide parameterized rotation gates.
    [] Fix picking issue on back side of sphere
    [] Document classes and clean up code
    [] Follow up on Jay's suggestion regarding y button: |+i> and |-i>
    [] Use min version of babylon.js
    [] Fix meta element so image will load into GitBook links
    [] Improve formatting of Pi rotations by justifying text instead of using spaces
    [] Consider providing capability of sliding "outcome probability" bar to manipulate Bloch sphere state
    [] Consider labeling the Ry gates |+i> and |-i>
-->
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <!--meta property="twitter:image" content="https://javafxpert.github.io/grok-bloch/images/bloch-sphere.png"-->
    <title>v0.12 Grokking the Bloch Sphere</title>
    <!--- Link to the last version of BabylonJS --->
    <!-- script src="https://cdn.babylonjs.com/babylon.js"></script -->
    <script src="js/thirdparty/babylon.js"></script>
    <script src="js/thirdparty/babylon.gui.min.js"></script>
    <script src="js/thirdparty/math.min.js"></script>
    <script src="js/qsphere.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width   : 100%;
            height  : 100%;
            margin  : 0;
            padding : 0;
        }

        #renderCanvas {
            width   : 100%;
            height  : 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<script>
    window.addEventListener('DOMContentLoaded', function(){

        let qSphere = null;

        // get the canvas DOM element
        const canvas = document.getElementById('renderCanvas');

        // load the 3D engine
        const engine = new BABYLON.Engine(canvas, true);

        // createScene function that creates and return the scene
        const createScene = function(){
            // Create the scene space
            const scene = new BABYLON.Scene(engine);

            qSphere = new QSphere("qSphere", scene, 0, 0);

            BABYLON.SceneOptimizer.OptimizeAsync(scene);

            scene.clearColor = new BABYLON.Color3( .75, .75, .75);

            // Add a camera to the scene and attach it to the canvas
            const camera = new BABYLON.ArcRotateCamera("camera1",  -Math.PI / 2.5, Math.PI / 2.5, 6, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            // Add lights to the scene
            const light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(-3, 7, 1), scene);

            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");



            scene.onPointerObservable.add((pointerInfo) => {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        // TODO: Find out how to identify that sphere was picked
                        if(pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh == blochSphere.sphere) {
                            console.log("pickedPoint: " + pointerInfo.pickInfo.pickedPoint);

                        }
                        break;
                }
            });

            // return the created scene
            return scene;
        }


        // call the createScene function
        const scene = createScene();

        // run the render loop
        engine.runRenderLoop(function(){
            scene.render();
        });

        // the canvas/window resize event handler
        window.addEventListener('resize', function(){
            engine.resize();
        });
    });
</script>
</body>
</html>